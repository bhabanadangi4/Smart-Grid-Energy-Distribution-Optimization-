# -*- coding: utf-8 -*-
"""Smart Grid Energy Distribution Optimization .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hUgYoXqaIF_H8Z_dnuxnd5zbPitOtGTt
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time
import random

from multiprocessing import Pool, cpu_count

# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

demand = pd.read_csv('/content/demand.csv', index_col=0)
supply = pd.read_csv('/content/supply.csv', index_col=0)
transmission_limits = pd.read_csv('/content/transmission_limits.csv', index_col=0)
cost_loss = pd.read_csv('/content/cost_loss.csv', index_col=0)

print("=== Demand ===")
print(demand.head())

print("\n=== Supply ===")
print(supply.head())

print("\n=== Transmission Limits ===")
print(transmission_limits.head())

print("\n=== Cost and Loss ===")
print(cost_loss.head())

def generate_chromosome(demand_df, supply_df, transmission_limits):
    hours = 24
    num_sources = 3
    num_nodes = 3

    chromosome = np.zeros((hours, num_sources, num_nodes))

    for h in range(hours):
        for s in range(num_sources):
            supply_left = supply_df.iloc[h, s]


            for n in range(num_nodes):
                max_transmit = transmission_limits.iloc[s, n]
                max_allocatable = min(supply_left, max_transmit)
                allocated = np.random.uniform(0, max_allocatable)
                chromosome[h, s, n] = allocated
                supply_left -= allocated
                if supply_left <= 0:
                    break
    return chromosome

def calculate_fitness(chromosome, demand, supply, cost_loss, transmission_limits):
    cost = np.sum(chromosome * cost_loss['cost'].values.reshape(1, 3, 10))
    loss = np.sum(chromosome * cost_loss['loss'].values.reshape(1, 3, 10))

    demand_values = demand.values.reshape(24, 10)
    supplied = np.sum(chromosome, axis=1)
    unmet_demand = np.sum(np.maximum(0, demand_values - np.sum(supplied, axis=1, keepdims=True)))

    penalty = 0
    for h in range(24):
        if np.any(np.sum(chromosome[h], axis=1) > supply.iloc[h].values):
            penalty += 1000
        if np.any(chromosome[h] > transmission_limits.values):
            penalty += 1000

    return cost + loss + unmet_demand + penalty

chrom = generate_chromosome(demand, supply, transmission_limits)
print("Shape of chromosome:", chrom.shape)
print("Sample for Hour 0:\n", chrom[0])

def evaluate_fitness(chromosome, demand_df, supply_df, transmission_limits, cost_loss_df):
    fitness = 0
    hours, num_sources, num_nodes = chromosome.shape

    for h in range(hours):
        hour_demand = demand_df.iloc[:, h].values
        hour_supply = supply_df.iloc[h].values

        supply_used = np.zeros(num_sources)
        node_received = np.zeros(num_nodes)

        for s in range(num_sources):
            for n in range(num_nodes):
                allocated = chromosome[h, s, n]
                loss_factor = 1 - (cost_loss_df.iloc[s]['Transmission_Loss_%'] / 100)

                if allocated > transmission_limits.iloc[s, n]:
                    fitness += 1000

                supply_used[s] += allocated
                node_received[n] += allocated * loss_factor

                # Cost
                fitness += allocated * cost_loss_df.iloc[s]['Unit_Cost_per_kWh']

        fitness += np.sum(np.abs(node_received - hour_demand)) * 10

        fitness += np.sum(np.maximum(supply_used - hour_supply, 0)) * 100

    return fitness

fit = evaluate_fitness(chrom, demand, supply, transmission_limits, cost_loss)
print("Fitness score of chromosome:", fit)

import numpy as np
import random
import matplotlib.pyplot as plt

POP_SIZE = 30
NUM_GENERATIONS = 50
MUTATION_RATE = 0.1
TOURNAMENT_SIZE = 3

# --- 1. Population Initialization ---
def initialize_population(pop_size, demand_df, supply_df, transmission_limits):
    return [generate_chromosome(demand_df, supply_df, transmission_limits) for _ in range(pop_size)]

# --- 2. Selection: Tournament Selection ---
def tournament_selection(population, fitnesses, k=TOURNAMENT_SIZE):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# --- 3. Crossover: Uniform Crossover ---
def crossover(parent1, parent2):
    child = np.copy(parent1)
    mask = np.random.rand(*parent1.shape) > 0.5
    child[mask] = parent2[mask]
    return child

# --- 4. Mutation: Add small Gaussian noise ---
def mutate(chromosome, mutation_rate=MUTATION_RATE):
    mutation_mask = np.random.rand(*chromosome.shape) < mutation_rate
    noise = np.random.normal(0, 5, size=chromosome.shape)  # std dev=5 units
    chromosome = chromosome + mutation_mask * noise
    chromosome = np.clip(chromosome, 0, None)  # no negative allocations
    return chromosome

# --- 5. GA Main Loop ---
def genetic_algorithm(demand_df, supply_df, transmission_limits, cost_loss_df):
    population = initialize_population(POP_SIZE, demand_df, supply_df, transmission_limits)
    best_fitness_progress = []

    for gen in range(NUM_GENERATIONS):
        fitnesses = [evaluate_fitness(ind, demand_df, supply_df, transmission_limits, cost_loss_df) for ind in population]
        best_fitness = min(fitnesses)
        best_fitness_progress.append(best_fitness)

        print(f"Generation {gen+1} - Best Fitness: {best_fitness:.2f}")

        new_population = []
        for _ in range(POP_SIZE):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)

        population = new_population


    best_idx = np.argmin(fitnesses)
    return population[best_idx], best_fitness_progress

# --- 6. Run GA ---
best_solution, fitness_history = genetic_algorithm(demand, supply, transmission_limits, cost_loss)

# --- 7. Plot Convergence ---
plt.plot(fitness_history)
plt.title("GA Fitness Convergence")
plt.xlabel("Generation")
plt.ylabel("Best Fitness")
plt.grid(True)
plt.show()

import numpy as np
import random
import matplotlib.pyplot as plt
from multiprocessing import Pool, cpu_count # Import Pool and cpu_count here

# --- GA Parameters ---
POP_SIZE = 30
NUM_GENERATIONS = 50
MUTATION_RATE = 0.1
TOURNAMENT_SIZE = 3

# --- 1. Population Initialization ---
def initialize_population(pop_size, demand_df, supply_df, transmission_limits):
    return [generate_chromosome(demand_df, supply_df, transmission_limits) for _ in range(pop_size)]

# --- 2. Selection: Tournament Selection ---
def tournament_selection(population, fitnesses, k=TOURNAMENT_SIZE):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]  # Return chromosome with best fitness

# --- 3. Crossover: Uniform Crossover ---
def crossover(parent1, parent2):
    child = np.copy(parent1)
    mask = np.random.rand(*parent1.shape) > 0.5
    child[mask] = parent2[mask]
    return child

# --- 4. Mutation: Add small Gaussian noise ---
def mutate(chromosome, mutation_rate=MUTATION_RATE):
    mutation_mask = np.random.rand(*chromosome.shape) < mutation_rate
    noise = np.random.normal(0, 5, size=chromosome.shape)
    chromosome = chromosome + mutation_mask * noise
    chromosome = np.clip(chromosome, 0, None)
    return chromosome

# --- Define the parallel fitness evaluation function here ---
def evaluate_population_fitness_parallel(population, demand_df, supply_df, transmission_limits, cost_loss_df):
    args = [(ind, demand_df, supply_df, transmission_limits, cost_loss_df) for ind in population]
    with Pool(cpu_count()) as pool:
        fitnesses = pool.starmap(evaluate_fitness, args)
    return fitnesses


# --- 5. GA Main Loop ---
def genetic_algorithm(demand_df, supply_df, transmission_limits, cost_loss_df):
    population = initialize_population(POP_SIZE, demand_df, supply_df, transmission_limits)
    best_fitness_progress = []

    for gen in range(NUM_GENERATIONS):
        fitnesses = evaluate_population_fitness_parallel(population, demand_df, supply_df, transmission_limits, cost_loss_df)
        best_fitness = min(fitnesses)
        best_fitness_progress.append(best_fitness)

        print(f"Generation {gen+1} - Best Fitness: {best_fitness:.2f}")

        new_population = []
        for _ in range(POP_SIZE):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)

        population = new_population

    best_idx = np.argmin(fitnesses)
    return population[best_idx], best_fitness_progress

# --- 6. Run GA ---
best_solution, fitness_history = genetic_algorithm(demand, supply, transmission_limits, cost_loss)

# --- 7. Plot Convergence ---
plt.plot(fitness_history)
plt.title("GA Fitness Convergence")
plt.xlabel("Generation")
plt.ylabel("Best Fitness")
plt.grid(True)
plt.show()



from multiprocessing import Pool, cpu_count

def evaluate_population_fitness_parallel(population, demand_df, supply_df, transmission_limits, cost_loss_df):
    args = [(ind, demand_df, supply_df, transmission_limits, cost_loss_df) for ind in population]
    with Pool(cpu_count()) as pool:
        fitnesses = pool.starmap(evaluate_fitness, args)
    return fitnesses

import time

def genetic_algorithm_serial(demand_df, supply_df, transmission_limits, cost_loss_df):
    population = initialize_population(POP_SIZE, demand_df, supply_df, transmission_limits)
    best_fitness_progress = []

    for gen in range(NUM_GENERATIONS):
        fitnesses = [evaluate_fitness(ind, demand_df, supply_df, transmission_limits, cost_loss_df) for ind in population]
        best_fitness = min(fitnesses)
        best_fitness_progress.append(best_fitness)

        print(f"[Serial] Generation {gen+1} - Best Fitness: {best_fitness:.2f}")

        new_population = []
        for _ in range(POP_SIZE):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)

        population = new_population

    best_idx = np.argmin(fitnesses)
    return population[best_idx], best_fitness_progress

def genetic_algorithm_parallel(demand_df, supply_df, transmission_limits, cost_loss_df):
    population = initialize_population(POP_SIZE, demand_df, supply_df, transmission_limits)
    best_fitness_progress = []

    for gen in range(NUM_GENERATIONS):
        fitnesses = evaluate_population_fitness_parallel(population, demand_df, supply_df, transmission_limits, cost_loss_df)
        best_fitness = min(fitnesses)
        best_fitness_progress.append(best_fitness)

        print(f"[Parallel] Generation {gen+1} - Best Fitness: {best_fitness:.2f}")

        new_population = []
        for _ in range(POP_SIZE):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)

        population = new_population

    best_idx = np.argmin(fitnesses)
    return population[best_idx], best_fitness_progress

start_time = time.time()
best_solution_serial, fitness_history_serial = genetic_algorithm_serial(demand, supply, transmission_limits, cost_loss)
end_time = time.time()
print(f"Serial GA took {end_time - start_time:.2f} seconds")

start_time = time.time()
best_solution_parallel, fitness_history_parallel = genetic_algorithm_parallel(demand, supply, transmission_limits, cost_loss)
end_time = time.time()
print(f"Parallel GA took {end_time - start_time:.2f} seconds")

plt.plot(fitness_history_serial, label="Serial GA")
plt.plot(fitness_history_parallel, label="Parallel GA")
plt.title("GA Fitness Convergence")
plt.xlabel("Generation")
plt.ylabel("Best Fitness")
plt.legend()
plt.grid(True)
plt.show()



import matplotlib.pyplot as plt

def plot_fitness_convergence(fitness_history):
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_history, marker='o', linestyle='-', color='b')
    plt.title('Genetic Algorithm Fitness Convergence')
    plt.xlabel('Generation')
    plt.ylabel('Best Fitness')
    plt.grid(True)
    plt.show()

plot_fitness_convergence(fitness_history)

import seaborn as sns

def plot_energy_allocation(chromosome, hour=11):
    data = chromosome[hour]
    sources = [f'Source{i+1}' for i in range(data.shape[0])]
    nodes = [f'Node{i+1}' for i in range(data.shape[1])]

    plt.figure(figsize=(8, 6))
    sns.heatmap(data, annot=True, fmt=".1f", xticklabels=nodes, yticklabels=sources, cmap="YlGnBu")
    plt.title(f'Energy Allocation at Hour {hour + 1}')
    plt.ylabel('Sources')
    plt.xlabel('Nodes')
    plt.show()


plot_energy_allocation(best_solution, hour=11)

def plot_demand_vs_received(chromosome, demand_df, cost_loss_df):
    hours = chromosome.shape[0]
    num_nodes = chromosome.shape[2]

    received = np.zeros((hours, num_nodes))

    for h in range(hours):
        for s in range(chromosome.shape[1]):
            loss_factor = 1 - cost_loss_df.iloc[s]['Transmission_Loss_%'] / 100
            received[h] += chromosome[h, s, :] * loss_factor

    nodes = demand_df.index.tolist()
    time_range = [f'H{i+1}' for i in range(hours)]

    plt.figure(figsize=(12, 8))
    for i, node in enumerate(nodes):
        plt.plot(time_range, demand_df.loc[node], label=f'{node} Demand', linestyle='--')
        plt.plot(time_range, received[:, i], label=f'{node} Received')
    plt.title('Demand vs Received Energy per Node Over 24 Hours')
    plt.xlabel('Hour')
    plt.ylabel('Energy Units')
    plt.xticks(rotation=45)
    plt.legend()
    plt.grid(True)
    plt.show()

plot_demand_vs_received(best_solution, demand, cost_loss)

def plot_supply_utilization(chromosome, supply_df):
    hours = chromosome.shape[0]
    num_sources = chromosome.shape[1]

    used_supply = np.zeros((hours, num_sources))
    for h in range(hours):
        for s in range(num_sources):
            used_supply[h, s] = np.sum(chromosome[h, s, :])

    sources = supply_df.columns.tolist()
    time_range = [f'H{i+1}' for i in range(hours)]

    plt.figure(figsize=(12, 6))
    for s in range(num_sources):
        plt.plot(time_range, used_supply[:, s], label=f'{sources[s]} Used')
        plt.plot(time_range, supply_df.iloc[:, s], label=f'{sources[s]} Max Supply', linestyle='--')

    plt.title('Supply Utilization vs Max Supply per Source')
    plt.xlabel('Hour')
    plt.ylabel('Energy Units')
    plt.xticks(rotation=45)
    plt.legend()
    plt.grid(True)
    plt.show()

# Usage:
plot_supply_utilization(best_solution, supply)

def plot_energy_allocation_histogram(chromosome):
    flattened = chromosome.flatten()

    plt.figure(figsize=(8,5))
    plt.hist(flattened, bins=30, color='skyblue', edgecolor='black')
    plt.title('Histogram of Energy Allocations in Chromosome')
    plt.xlabel('Energy Units')
    plt.ylabel('Frequency')
    plt.grid(True)
    plt.show()

# Usage:
plot_energy_allocation_histogram(best_solution)

def mutation_impact(parent, mutated_child):
    diff = np.abs(mutated_child - parent)
    avg_change = np.mean(diff)
    print(f"Average gene change due to mutation: {avg_change:.2f}")

def plot_energy_loss_per_source(chromosome, cost_loss_df):
    hours, num_sources, num_nodes = chromosome.shape
    total_loss = np.zeros(num_sources)

    for s in range(num_sources):
        for h in range(hours):
            total_alloc = np.sum(chromosome[h, s, :])
            loss = total_alloc * (cost_loss_df.iloc[s]['Transmission_Loss_%'] / 100)
            total_loss[s] += loss

    sources = [f'Source{i+1}' for i in range(num_sources)]

    plt.figure(figsize=(8,5))
    plt.bar(sources, total_loss, color='salmon')
    plt.title('Total Transmission Loss per Source over 24 hours')
    plt.ylabel('Energy Units Lost')
    plt.show()
plot_energy_loss_per_source(best_solution, cost_loss)

import seaborn as sns

def plot_heatmaps(best_solution):
    num_hours, num_sources, num_nodes = best_solution.shape
    for source in range(num_sources):
        plt.figure(figsize=(12, 6))
        sns.heatmap(best_solution[:, source, :], cmap="YlGnBu", annot=False)
        plt.title(f"Energy Allocation Heatmap - Source {source+1}")
        plt.xlabel("Demand Nodes")
        plt.ylabel("Hours")
        plt.show()

plot_heatmaps(best_solution)

# Assuming `demand`, `supply`, and `best_solution` are loaded
hourly_demand = demand.sum(axis=1).values
hourly_supply = supply.sum(axis=1).values
hourly_received = best_solution.sum(axis=(1, 2))

plt.figure(figsize=(12, 6))
plt.plot(hourly_demand, label="Total Demand", linewidth=2)
plt.plot(hourly_supply, label="Total Supply", linewidth=2)
plt.plot(hourly_received, label="Energy Received", linewidth=2)
plt.title("Hourly Supply vs Demand vs Received Energy")
plt.xlabel("Hour")
plt.ylabel("Energy (kWh)")
plt.legend()
plt.grid(True)
plt.show()

flattened_genes = best_solution.flatten()

plt.figure(figsize=(10, 5))
plt.hist(flattened_genes, bins=30, color="teal", edgecolor="black")
plt.title("Distribution of Gene Values (Best Chromosome)")
plt.xlabel("Energy Allocation")
plt.ylabel("Frequency")
plt.grid(True)
plt.show()

# Sum energy per hour per node
hourly_node_energy = best_solution.sum(axis=1)  # shape: [24 hours x 10 nodes]

plt.figure(figsize=(12, 6))
plt.stackplot(range(24), hourly_node_energy.T, labels=[f"Node {i+1}" for i in range(hourly_node_energy.shape[1])])
plt.title("Stacked Energy Received by Nodes Over 24 Hours")
plt.xlabel("Hour")
plt.ylabel("Energy Received (kWh)")
plt.legend(loc="upper left", ncol=2)
plt.grid(True)
plt.show()

# Sum energy to each node over 24 hours and 3 sources
node_energy = best_solution.sum(axis=(0, 1))  # shape: [10 nodes]

plt.figure(figsize=(10, 6))
sns.boxplot(data=best_solution.reshape(24*3, -1))  # flatten to [72 x 10] for boxplot per node
plt.title("Boxplot of Energy Distribution per Node")
plt.xlabel("Node")
plt.ylabel("Energy Allocation")
plt.grid(True)
plt.show()

energy_per_hour = best_solution.sum(axis=2)  # shape: [24 hours x 3 sources]

plt.figure(figsize=(10, 6))
sns.violinplot(data=energy_per_hour, inner="box")
plt.title("Violin Plot of Hourly Energy Output per Source")
plt.xlabel("Source")
plt.ylabel("Energy (kWh)")
plt.xticks(ticks=[0,1,2], labels=["Source 1", "Source 2", "Source 3"])
plt.grid(True)
plt.show()

node_hour_usage = best_solution.sum(axis=1)  # shape: [24 hours x 10 nodes]

plt.figure(figsize=(12, 6))
sns.heatmap(node_hour_usage.T, cmap="magma", xticklabels=range(24), yticklabels=[f"Node {i+1}" for i in range(10)])
plt.title("Node Energy Usage Intensity per Hour")
plt.xlabel("Hour")
plt.ylabel("Node")
plt.show()

# Total energy received by each node (summed across all hours and sources)
node_contributions = best_solution.sum(axis=(0, 1))
node_labels = [f"Node {i+1}" for i in range(node_contributions.shape[0])]

plt.figure(figsize=(8, 8))
plt.pie(node_contributions, labels=node_labels, autopct='%1.1f%%', startangle=90, colors=plt.cm.Set3.colors)
plt.title("Energy Received by Each Demand Node")
plt.axis("equal")
plt.show()

hourly_demand = demand.sum(axis=1)
top_hours = hourly_demand.sort_values(ascending=False).head(5)

plt.figure(figsize=(8, 5))
plt.bar(top_hours.index.astype(str), top_hours.values, color="tomato")
plt.title("Top 5 Peak Energy Demand Hours")
plt.xlabel("Hour")
plt.ylabel("Total Demand (kWh)")
plt.grid(True)
plt.show()

plt.plot(fitness_history_serial, label="Serial GA")
plt.plot(fitness_history_parallel, label="Parallel GA")
plt.title("Genetic Algorithm Convergence: Serial vs Parallel")
plt.xlabel("Generation")
plt.ylabel("Best Fitness")
plt.legend()
plt.grid(True)
plt.show()



